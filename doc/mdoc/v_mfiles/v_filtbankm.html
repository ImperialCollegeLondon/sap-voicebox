<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of v_filtbankm</title>
  <meta name="keywords" content="v_filtbankm">
  <meta name="description" content="V_FILTBANKM determine matrix for a linear/mel/erb/bark-spaced v_filterbank [X,IL,IH]=(P,N,FS,FL,FH,W)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>

<!-- index.html v_mfiles -->
<h1>v_filtbankm

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>V_FILTBANKM determine matrix for a linear/mel/erb/bark-spaced v_filterbank [X,IL,IH]=(P,N,FS,FL,FH,W)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [x,cf,il,ih]=v_filtbankm(p,n,fs,fl,fh,w) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">V_FILTBANKM determine matrix for a linear/mel/erb/bark-spaced v_filterbank [X,IL,IH]=(P,N,FS,FL,FH,W)

 Usage:
 (1) Calcuate the Mel-frequency Cepstral Coefficients

        f=v_rfft(s);                                    % v_rfft() returns only 1+floor(n/2) coefficients
         x=v_filtbankm(p,n,fs,0,fs/2,'m');              % n is the fft length, p is the number of filters wanted
         z=log(x*abs(f).^2);                            % multiply x by the power spectrum
         c=dct(z);                                      % take the DCT

 (2) Calcuate the Mel-frequency Cepstral Coefficients efficiently

        f=fft(s);                                      % n is the fft length, p is the number of filters wanted
        [x,cf,na,nb]=v_filtbankm(p,n,fs,0,fs/2,'m');   % na:nb gives the fft bins that are needed
        z=log(x*(f(na:nb)).*conj(f(na:nb)));           % multiply x by the power spectrum
         c=dct(z);                                      % take the DCT

 (3) Plot the calculated filterbanks as a graph

        plot((0:floor(n/2))*fs/n,v_filtbankm(p,n,fs,0,fs/2,'m')')   % fs=sample frequency

 (4) Plot the calculated filterbanks as a spectrogram

        v_filtbankm(p,n,fs,0,fs/2,'m');

 Inputs:
       p   number of filters in v_filterbank or the filter spacing in k-mel/bark/erb (see 'p' and 'P' options) [ceil(4.6*log10(fs))]
        n   length of dft
           or [nfrq dfrq frq1] nfrq=number of input frequency bins, dfrq=frequency increment (Hz), frq1=first bin freq (Hz)
        fs  sample rate in Hz
        fl  low end of the lowest filter in Hz (or in mel/erb/bark/log10 with 'h' option) [default = 0 or 30Hz for 'l' option]
        fh  high end of highest filter in Hz (or in mel/erb/bark/log10 with 'h' option) [default = fs/2]
        w   any sensible combination of the following:

             'b' = bark scale instead of mel
             'e' = erb-rate scale
             'l' = log10 Hz frequency scale
             'f' = linear frequency scale [default]
             'm' = mel frequency scale

             'n' - round to the nearest FFT bin so each row of x contains only one non-zero entry

             'c' = fl &amp; fh specify centre of low and high filters instead of edges
             'h' = fl &amp; fh are in mel/erb/bark/log10 instead of Hz
             'H' = give cf outputs in mel/erb/bark/log10 instead of Hz

              'y' = lowest filter remains at 1 down to 0 frequency and highest filter remains at 1 up to nyquist freqency
                    The total power in the fft is preserved (unless 'u' is specified).
             'Y' = extend only at low frequency end (or high end if 'y' also specified)

             'p' = input P specifies the number of filters [default if P&gt;=1]
             'P' = input P specifies the filter spacing [default if P&lt;1]

             'u' = input and output are power per Hz instead of power.
             'U' = input is power but output is power per Hz.

             's' = single-sided input: do not include symmetric negative frequencies (i.e. non-DC inputs have already been doubled)
             'S' = single-sided output: do not mirror the non-DC filter characteristics (i.e. double non-DC outputs)

             'g' = plot filter coefficients as graph
             'G' = plot filter coefficients as spectrogram image [default if no output arguments present]


 Outputs:    x(p,k)  a sparse matrix containing the v_filterbank amplitudes
                    If the il and ih outputs are included then k=ih-il+1 otherwise k=1+floor(n/2)
                   Note that the peak filter values equal 2 to account for the power in the negative FFT frequencies.
           cf(p)   the v_filterbank centre frequencies in Hz (or in mel/erb/bark/log10 with 'H' option)
            il      the lowest fft bin with a non-zero coefficient
            ih      the highest fft bin with a non-zero coefficient

 The routine performs interpolation of the input spectrum by convolving the power spectrum
 with a triangular filter and then simulates a v_filterbank with asymetric triangular filters.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">

<li><a href="v_bark2frq.html" class="code" title="function [f,c] = v_bark2frq(b,m)">v_bark2frq</a>	V_BARK2FRQ  Convert the BARK frequency scale to Hertz FRQ=(BARK)</li>
<li><a href="v_cblabel.html" class="code" title="function c=v_cblabel(l,h)">v_cblabel</a>	V_CBLABEL add a label to a colorbar c=(l,h)</li>
<li><a href="v_erb2frq.html" class="code" title="function [frq,bnd] = v_erb2frq(erb)">v_erb2frq</a>	V_ERB2FRQ  Convert ERB frequency scale to Hertz FRQ=(ERB)</li>
<li><a href="v_frq2bark.html" class="code" title="function [b,c] = v_frq2bark(f,m)">v_frq2bark</a>	V_FRQ2BARK  Convert Hertz to BARK frequency scale BARK=(FRQ)</li>
<li><a href="v_frq2erb.html" class="code" title="function [erb,bnd] = v_frq2erb(frq)">v_frq2erb</a>	V_FRQ2ERB  Convert Hertz to ERB frequency scale ERB=(FRQ)</li>
<li><a href="v_frq2mel.html" class="code" title="function [mel,mr] = v_frq2mel(frq)">v_frq2mel</a>	V_FRQ2ERB  Convert Hertz to Mel frequency scale MEL=(FRQ)</li>
<li><a href="v_mel2frq.html" class="code" title="function [frq,mr] = v_mel2frq(mel)">v_mel2frq</a>	V_MEL2FRQ  Convert Mel frequency scale to Hertz FRQ=(MEL)</li>
<li><a href="v_xticksi.html" class="code" title="function s=v_xticksi(ah)">v_xticksi</a>	V_XTIXKSI labels the x-axis of a plot using SI multipliers S=(AH)</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">

<li><a href="v_fxpefac.html" class="code" title="function [fx,tx,pv,fv]=v_fxpefac(s,fs,tinc,m,pp)">v_fxpefac</a>	V_FXPEFAC PEFAC pitch tracker [FX,TT,PV,FV]=(S,FS,TINC,M,PP)</li>
<li><a href="v_spendred.html" class="code" title="function [enhanced_speech] = v_spendred(input_speech,fs,algo_params)">v_spendred</a>	V_SPENDRED Speech Enhancement and Dereverberation by Doire</li>
</ul>
<!-- crossreference -->




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [x,cf,il,ih]=v_filtbankm(p,n,fs,fl,fh,w)</a>
0002 <span class="comment">%V_FILTBANKM determine matrix for a linear/mel/erb/bark-spaced v_filterbank [X,IL,IH]=(P,N,FS,FL,FH,W)</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Usage:</span>
0005 <span class="comment">% (1) Calcuate the Mel-frequency Cepstral Coefficients</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%        f=v_rfft(s);                                    % v_rfft() returns only 1+floor(n/2) coefficients</span>
0008 <span class="comment">%         x=v_filtbankm(p,n,fs,0,fs/2,'m');              % n is the fft length, p is the number of filters wanted</span>
0009 <span class="comment">%         z=log(x*abs(f).^2);                            % multiply x by the power spectrum</span>
0010 <span class="comment">%         c=dct(z);                                      % take the DCT</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% (2) Calcuate the Mel-frequency Cepstral Coefficients efficiently</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%        f=fft(s);                                      % n is the fft length, p is the number of filters wanted</span>
0015 <span class="comment">%        [x,cf,na,nb]=v_filtbankm(p,n,fs,0,fs/2,'m');   % na:nb gives the fft bins that are needed</span>
0016 <span class="comment">%        z=log(x*(f(na:nb)).*conj(f(na:nb)));           % multiply x by the power spectrum</span>
0017 <span class="comment">%         c=dct(z);                                      % take the DCT</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% (3) Plot the calculated filterbanks as a graph</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%        plot((0:floor(n/2))*fs/n,v_filtbankm(p,n,fs,0,fs/2,'m')')   % fs=sample frequency</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% (4) Plot the calculated filterbanks as a spectrogram</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%        v_filtbankm(p,n,fs,0,fs/2,'m');</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Inputs:</span>
0028 <span class="comment">%       p   number of filters in v_filterbank or the filter spacing in k-mel/bark/erb (see 'p' and 'P' options) [ceil(4.6*log10(fs))]</span>
0029 <span class="comment">%        n   length of dft</span>
0030 <span class="comment">%           or [nfrq dfrq frq1] nfrq=number of input frequency bins, dfrq=frequency increment (Hz), frq1=first bin freq (Hz)</span>
0031 <span class="comment">%        fs  sample rate in Hz</span>
0032 <span class="comment">%        fl  low end of the lowest filter in Hz (or in mel/erb/bark/log10 with 'h' option) [default = 0 or 30Hz for 'l' option]</span>
0033 <span class="comment">%        fh  high end of highest filter in Hz (or in mel/erb/bark/log10 with 'h' option) [default = fs/2]</span>
0034 <span class="comment">%        w   any sensible combination of the following:</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%             'b' = bark scale instead of mel</span>
0037 <span class="comment">%             'e' = erb-rate scale</span>
0038 <span class="comment">%             'l' = log10 Hz frequency scale</span>
0039 <span class="comment">%             'f' = linear frequency scale [default]</span>
0040 <span class="comment">%             'm' = mel frequency scale</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%             'n' - round to the nearest FFT bin so each row of x contains only one non-zero entry</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%             'c' = fl &amp; fh specify centre of low and high filters instead of edges</span>
0045 <span class="comment">%             'h' = fl &amp; fh are in mel/erb/bark/log10 instead of Hz</span>
0046 <span class="comment">%             'H' = give cf outputs in mel/erb/bark/log10 instead of Hz</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%              'y' = lowest filter remains at 1 down to 0 frequency and highest filter remains at 1 up to nyquist freqency</span>
0049 <span class="comment">%                    The total power in the fft is preserved (unless 'u' is specified).</span>
0050 <span class="comment">%             'Y' = extend only at low frequency end (or high end if 'y' also specified)</span>
0051 <span class="comment">%</span>
0052 <span class="comment">%             'p' = input P specifies the number of filters [default if P&gt;=1]</span>
0053 <span class="comment">%             'P' = input P specifies the filter spacing [default if P&lt;1]</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%             'u' = input and output are power per Hz instead of power.</span>
0056 <span class="comment">%             'U' = input is power but output is power per Hz.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%             's' = single-sided input: do not include symmetric negative frequencies (i.e. non-DC inputs have already been doubled)</span>
0059 <span class="comment">%             'S' = single-sided output: do not mirror the non-DC filter characteristics (i.e. double non-DC outputs)</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%             'g' = plot filter coefficients as graph</span>
0062 <span class="comment">%             'G' = plot filter coefficients as spectrogram image [default if no output arguments present]</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%</span>
0065 <span class="comment">% Outputs:    x(p,k)  a sparse matrix containing the v_filterbank amplitudes</span>
0066 <span class="comment">%                    If the il and ih outputs are included then k=ih-il+1 otherwise k=1+floor(n/2)</span>
0067 <span class="comment">%                   Note that the peak filter values equal 2 to account for the power in the negative FFT frequencies.</span>
0068 <span class="comment">%           cf(p)   the v_filterbank centre frequencies in Hz (or in mel/erb/bark/log10 with 'H' option)</span>
0069 <span class="comment">%            il      the lowest fft bin with a non-zero coefficient</span>
0070 <span class="comment">%            ih      the highest fft bin with a non-zero coefficient</span>
0071 <span class="comment">%</span>
0072 <span class="comment">% The routine performs interpolation of the input spectrum by convolving the power spectrum</span>
0073 <span class="comment">% with a triangular filter and then simulates a v_filterbank with asymetric triangular filters.</span>
0074 
0075 <span class="comment">%</span>
0076 <span class="comment">% References:</span>
0077 <span class="comment">%</span>
0078 <span class="comment">% [1] S. S. Stevens, J. Volkman, and E. B. Newman. A scale for the measurement</span>
0079 <span class="comment">%     of the psychological magnitude of pitch. J. Acoust Soc Amer, 8: 185-190, 1937.</span>
0080 <span class="comment">% [2] S. Davis and P. Mermelstein. Comparison of parametric representations for</span>
0081 <span class="comment">%     monosyllabic word recognition in continuously spoken sentences.</span>
0082 <span class="comment">%     IEEE Trans Acoustics Speech and Signal Processing, 28 (4): 357-366, Aug. 1980.</span>
0083 
0084 <span class="comment">% Bugs/Suggestions</span>
0085 <span class="comment">% (1) default frequencies won't work if the h option is specified</span>
0086 <span class="comment">% (2) low default frequency is invalid if the 'l' option is specified</span>
0087 <span class="comment">% (3) Add 'z' option to include a DC output as the first coefficient</span>
0088 <span class="comment">% (4) Add 'Z' option to ignore the DC input component</span>
0089 <span class="comment">% (5) Add 'i' option to calculate the inverse of x instead</span>
0090 
0091 <span class="comment">%      Copyright (C) Mike Brookes 1997-2009</span>
0092 <span class="comment">%      Version: $Id: v_filtbankm.m 10865 2018-09-21 17:22:45Z dmb $</span>
0093 <span class="comment">%</span>
0094 <span class="comment">%   VOICEBOX is a MATLAB toolbox for speech processing.</span>
0095 <span class="comment">%   Home page: http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/voicebox.html</span>
0096 <span class="comment">%</span>
0097 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0098 <span class="comment">%   This program is free software; you can redistribute it and/or modify</span>
0099 <span class="comment">%   it under the terms of the GNU General Public License as published by</span>
0100 <span class="comment">%   the Free Software Foundation; either version 2 of the License, or</span>
0101 <span class="comment">%   (at your option) any later version.</span>
0102 <span class="comment">%</span>
0103 <span class="comment">%   This program is distributed in the hope that it will be useful,</span>
0104 <span class="comment">%   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
0105 <span class="comment">%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
0106 <span class="comment">%   GNU General Public License for more details.</span>
0107 <span class="comment">%</span>
0108 <span class="comment">%   You can obtain a copy of the GNU General Public License from</span>
0109 <span class="comment">%   http://www.gnu.org/copyleft/gpl.html or by writing to</span>
0110 <span class="comment">%   Free Software Foundation, Inc.,675 Mass Ave, Cambridge, MA 02139, USA.</span>
0111 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0112 
0113 <span class="comment">% Notes:</span>
0114 <span class="comment">% (1) In the comments, &quot;FFT bin_0&quot; assumes DC = bin 0 whereas &quot;FFT bin_1&quot; means DC = bin 1</span>
0115 <span class="comment">% (2) &quot;input&quot; and &quot;output&quot; need to be interchanged if the 'i' option is given</span>
0116 
0117 <span class="keyword">if</span> nargin &lt; 6                                       <span class="comment">% if no mode option, w, is specified</span>
0118     w=<span class="string">'f'</span>;                                          <span class="comment">% default mode option: 'f' = linear output frequency scale</span>
0119 <span class="keyword">elseif</span> isempty(w)
0120     w=<span class="string">' '</span>;                                          <span class="comment">% ensure mode, w, is not empty</span>
0121 <span class="keyword">end</span>
0122 wr=max(any(repmat(<span class="string">'lebm'</span>,length(w),1)==repmat(w',1,4),1).*(1:4)); <span class="comment">% output warping: 0=linear,1=log,2=erbrate,3=bark,4=mel</span>
0123 <span class="keyword">if</span> nargin &lt; 5 || ~numel(fh)
0124     fh=0.5*fs;                                      <span class="comment">% max freq is the nyquist</span>
0125 <span class="keyword">end</span>
0126 <span class="keyword">if</span> nargin &lt; 4 || ~numel(fl)
0127     fl=30*(wr==1);                                  <span class="comment">% lower limit is 0 Hz unless 'l' option specified, in which case it is 30 Hz</span>
0128 <span class="keyword">end</span>
0129 fa=0;                                               <span class="comment">% first input frequency bin defaults to 0</span>
0130 <span class="keyword">if</span> numel(n)&gt;1
0131     nf=n(1);                                        <span class="comment">% number of input frequency bins</span>
0132     df=n(2);                                        <span class="comment">% input frequency bin spacing</span>
0133     <span class="keyword">if</span> numel(n)&gt;2
0134         fa=n(3);                                    <span class="comment">% frequency of first bin</span>
0135     <span class="keyword">end</span>
0136 <span class="keyword">else</span>                                                <span class="comment">% n gives dft length</span>
0137     nf=1+floor(n/2);                                <span class="comment">% number of input frequency bins</span>
0138     df=fs/n;                                        <span class="comment">% input frequency bin spacing</span>
0139 <span class="keyword">end</span>
0140 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
0141 fin0=fa+(0:nf-1)*df;  <span class="comment">% input frequency bins</span>
0142 mflh=[fl fh];
0143 <span class="keyword">if</span> ~any(w==<span class="string">'h'</span>)             <span class="comment">% convert Hz to mel/erb/...</span>
0144 =======
0145 fin0=fa+(0:nf-1)*df;                                <span class="comment">% nf input frequency bins linearly spaced from fa to fa+(nf-1)*df</span>
0146 mflh=[fl fh];                                       <span class="comment">% low and high limits of filterbank triangular filters</span>
0147 <span class="keyword">if</span> ~any(w==<span class="string">'h'</span>)                                     <span class="comment">% convert mflh from Hz to mel/erb/... unless already converted via 'h' option</span>
0148 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 30d6258f912a2a55d0ce3242cdf7e35872a7da7d
0149     <span class="keyword">switch</span> wr
0150         <span class="keyword">case</span> 1                                      <span class="comment">% 'l' = log scaled</span>
0151             <span class="keyword">if</span> fl&lt;=0
0152                 error(<span class="string">'Low frequency limit must be &gt;0 for ''l'' option'</span>);
0153             <span class="keyword">end</span>
0154             mflh=log10(mflh);                       <span class="comment">% convert frequency limits into log10 Hz</span>
0155         <span class="keyword">case</span> 2                                      <span class="comment">% 'e' = erb-rate scaled</span>
0156             mflh=<a href="v_frq2erb.html" class="code" title="function [erb,bnd] = v_frq2erb(frq)">v_frq2erb</a>(mflh);                   <span class="comment">% convert frequency limits into erb-rate</span>
0157         <span class="keyword">case</span> 3                                      <span class="comment">% 'b' = bark scaled</span>
0158             mflh=<a href="v_frq2bark.html" class="code" title="function [b,c] = v_frq2bark(f,m)">v_frq2bark</a>(mflh);                  <span class="comment">% convert frequency limits into bark</span>
0159         <span class="keyword">case</span> 4                                      <span class="comment">% 'm' = mel scaled</span>
0160             mflh=<a href="v_frq2mel.html" class="code" title="function [mel,mr] = v_frq2mel(frq)">v_frq2mel</a>(mflh);                   <span class="comment">% convert frequency limits into mel</span>
0161     <span class="keyword">end</span>
0162 <span class="keyword">end</span>
0163 melrng=mflh(2)-mflh(1);                             <span class="comment">% mel/erb/... range</span>
0164 <span class="keyword">if</span> isempty(p)
0165     p=ceil(4.6*log10(2*(fa+(nf-1)*df)));            <span class="comment">% default number of output filters</span>
0166 <span class="keyword">end</span>
0167 puc=any(w==<span class="string">'P'</span>) || (p&lt;1) &amp;&amp; ~any(w==<span class="string">'p'</span>);           <span class="comment">% input p specifies the filter spacing rather than the number of filters</span>
0168 <span class="keyword">if</span> any(w==<span class="string">'c'</span>)                                      <span class="comment">% 'c' option: melrng excludes outer halves of the first and last filters</span>
0169     <span class="keyword">if</span> puc                                          <span class="comment">% the p input specifies the filter spacing</span>
0170         p=round(melrng/(p*1000))+1;                 <span class="comment">% p now gives the number of filters</span>
0171     <span class="keyword">end</span>
0172     melinc=melrng/(p-1);                            <span class="comment">% inter-filter increment in mel</span>
0173     mflh=mflh+(-1:2:1)*melinc;                      <span class="comment">% update mflh to include the full width of all filters</span>
0174 <span class="keyword">else</span>                                                <span class="comment">% melrng includes full width of all filters</span>
0175     <span class="keyword">if</span> puc                                          <span class="comment">% the p input specifies the filter spacing</span>
0176         p=round(melrng/(p*1000))-1;                 <span class="comment">% p now gives the number of filters</span>
0177     <span class="keyword">end</span>
0178     melinc=melrng/(p+1);                            <span class="comment">% inter-filter increment in mel</span>
0179 <span class="keyword">end</span>
0180 <span class="comment">%</span>
0181 <span class="comment">% Calculate the FFT bins0 corresponding to the filters</span>
0182 <span class="comment">%</span>
0183 cf=mflh(1)+(0:p+1)*melinc;                          <span class="comment">% centre frequencies in mel/erb/... including dummy ends</span>
0184 cf(2:end)=max(cf(2:end),0);                         <span class="comment">% only the first point can be negative</span>
0185 <span class="keyword">switch</span> wr                                           <span class="comment">% convert centre frequencies from mel/erb/... to Hz</span>
0186     <span class="keyword">case</span> 1                                          <span class="comment">% 'l' = log scaled</span>
0187         mb=10.^(cf);
0188     <span class="keyword">case</span> 2                                          <span class="comment">% 'e' = erb-rate scaled</span>
0189         mb=<a href="v_erb2frq.html" class="code" title="function [frq,bnd] = v_erb2frq(erb)">v_erb2frq</a>(cf);
0190     <span class="keyword">case</span> 3                                          <span class="comment">% 'b' = bark scaled</span>
0191         mb=<a href="v_bark2frq.html" class="code" title="function [f,c] = v_bark2frq(b,m)">v_bark2frq</a>(cf);
0192     <span class="keyword">case</span> 4                                          <span class="comment">% 'm' = mel scaled</span>
0193         mb=<a href="v_mel2frq.html" class="code" title="function [frq,mr] = v_mel2frq(mel)">v_mel2frq</a>(cf);
0194     <span class="keyword">otherwise</span>                                       <span class="comment">% [default] = linear scaled</span>
0195         mb=cf;
0196 <span class="keyword">end</span>
0197 <span class="comment">%</span>
0198 <span class="comment">% first sort out 2-sided input frequencies</span>
0199 <span class="comment">%</span>
0200 fin=fin0;                                           <span class="comment">% input frequency bin values</span>
0201 fin(nf+1)=fin(nf)+df;                               <span class="comment">% add on a dummy point at the high end</span>
0202 <span class="keyword">if</span> fin(1)==0
0203     fin=[-fin(nf+1:-1:2) fin];
0204 <span class="keyword">elseif</span> fin(1)&lt;=df/2
0205     fin=[-fin(nf+1:-1:1) fin];
0206 <span class="keyword">elseif</span> fin(1)&lt;df
0207     fin=[-fin(nf+1:-1:1) fin(1)-df df-fin(1) fin];
0208 <span class="keyword">elseif</span> fin(1)==df
0209     fin=[-fin(nf+1:-1:1) 0 fin];
0210 <span class="keyword">else</span>
0211     fin=[-fin(nf+1:-1:1) df-fin(1) fin(1)-df fin];
0212 <span class="keyword">end</span>
0213 nfin=length(fin);                                   <span class="comment">% length of extended input frequency list</span>
0214 <span class="comment">%</span>
0215 <span class="comment">% now sort out the interleaving</span>
0216 <span class="comment">%</span>
0217 fout=mb;                                            <span class="comment">% output frequencies in Hz</span>
0218 lowex=any(w==<span class="string">'y'</span>)~=any(w==<span class="string">'Y'</span>);                     <span class="comment">% extend to 0 Hz</span>
0219 highex=any(w==<span class="string">'y'</span>) &amp;&amp; (fout(end-1)&lt;fin(end));       <span class="comment">% extend at high end</span>
0220 <span class="keyword">if</span> lowex
0221     fout=[0 0 fout(2:end)];
0222 <span class="keyword">end</span>
0223 <span class="keyword">if</span> highex
0224     fout=[fout(1:end-1) fin(end) fin(end)];
0225 <span class="keyword">end</span>
0226 mfout=length(fout);
0227 <span class="keyword">if</span> any(w==<span class="string">'u'</span>) || any(w==<span class="string">'U'</span>)
0228     gout=fout(3:mfout)-fout(1:mfout-2);
0229     gout=2*(gout+(gout==0)).^(-1);                  <span class="comment">% Gain of output triangles</span>
0230 <span class="keyword">else</span>
0231     gout=ones(1,mfout-2);
0232 <span class="keyword">end</span>
0233 <span class="keyword">if</span> any(w==<span class="string">'S'</span>)
0234     msk=fout(2:mfout-1)~=0;
0235     gout(msk)=2*gout(msk);                          <span class="comment">% double non-DC outputs for a 1-sided output spectrum</span>
0236 <span class="keyword">end</span>
0237 <span class="keyword">if</span> any(w==<span class="string">'u'</span>)
0238     gin=ones(1,nfin-2);
0239 <span class="keyword">else</span>
0240     gin=fin(3:nfin)-fin(1:nfin-2);
0241     gin=2*(gin+(gin==0)).^(-1);                     <span class="comment">% Gain of input triangles</span>
0242 <span class="keyword">end</span>
0243 msk=fin(2:end-1)==0;
0244 <span class="keyword">if</span> any(w==<span class="string">'s'</span>)
0245     gin(~msk)=0.5*gin(~msk);                        <span class="comment">% halve non-DC inputs to change back to a 2-sided spectrum</span>
0246 <span class="keyword">end</span>
0247 <span class="keyword">if</span> lowex
0248     gin(msk)=2*gin(msk);                            <span class="comment">% double DC input to preserve its power</span>
0249 <span class="keyword">end</span>
0250 foutin=[fout fin];
0251 nfall=length(foutin);
0252 wleft=[0 fout(2:mfout)-fout(1:mfout-1) 0 fin(2:nfin)-fin(1:nfin-1)]; <span class="comment">% left width</span>
0253 wright=[wleft(2:end) 0];                            <span class="comment">% right width</span>
0254 ffact=[0 gout 0 0 gin(1:min(nf,nfin-nf-2)) zeros(1,max(nfin-2*nf-2,0)) gin(nfin-nf-1:nfin-2) 0]; <span class="comment">% gain of triangle posts</span>
0255 <span class="comment">% ffact(wleft+wright==0)=0;                         % disable null width triangles shouldn't need this if all frequencies are distinct</span>
0256 [fall,ifall]=sort(foutin);
0257 jfall=zeros(1,nfall);
0258 infall=1:nfall;
0259 jfall(ifall)=infall;                                <span class="comment">% unsort-&gt;sort index</span>
0260 ffact(ifall([1:max(jfall(1),jfall(mfout+1))-2 min(jfall(mfout),jfall(nfall))+2:nfall]))=0;  <span class="comment">% zap nodes that are much too small/big</span>
0261 nxto=cumsum(ifall&lt;=mfout);
0262 nxti=cumsum(ifall&gt;mfout);
0263 nxtr=min(nxti+1+mfout,nfall);                       <span class="comment">% next input node to the right of each value (or nfall if none)</span>
0264 nxtr(ifall&gt;mfout)=1+nxto(ifall&gt;mfout);              <span class="comment">% next post to the right of opposite type (unsorted indexes)</span>
0265 nxtr=nxtr(jfall);                                   <span class="comment">% next post to the right of opposite type (converted to unsorted indices) or if none: nfall/(mfout+1)</span>
0266 <span class="comment">%</span>
0267 <span class="comment">% Each triangle is &quot;attached&quot; to the node at its extreme right end.</span>
0268 <span class="comment">% The general result for integrating the product of two trapesiums with</span>
0269 <span class="comment">% heights (a,b) and (c,d) over a width x is (ad+bc+2bd+2ac)*x/6</span>
0270 <span class="comment">%</span>
0271 <span class="comment">% integrate product of lower triangles</span>
0272 <span class="comment">%</span>
0273 msk0=(ffact&gt;0);
0274 msk=msk0 &amp; (ffact(nxtr)&gt;0);                         <span class="comment">% select appropriate triangle pairs (unsorted indices)</span>
0275 ix1=infall(msk);                                    <span class="comment">% unsorted indices of leftmost post of pair</span>
0276 jx1=nxtr(msk);                                      <span class="comment">% unsorted indices of rightmost post of pair</span>
0277 vfgx=foutin(ix1)-foutin(jx1-1);                     <span class="comment">% length of right triangle to the left of the left post</span>
0278 yx=min(wleft(ix1),vfgx);                            <span class="comment">% integration length</span>
0279 wx1=ffact(ix1).*ffact(jx1).*yx.*(wleft(ix1).*vfgx-yx.*(0.5*(wleft(ix1)+vfgx)-yx/3))./(wleft(ix1).*wleft(jx1)+(yx==0));
0280 
0281 <span class="comment">% integrate product of upper triangles</span>
0282 
0283 nxtu=max([nxtr(2:end)-1 0],1);
0284 msk=msk0 &amp; (ffact(nxtu)&gt;0);
0285 ix2=infall(msk);                                    <span class="comment">% unsorted indices of leftmost post of pair</span>
0286 jx2=nxtu(msk);                                      <span class="comment">% unsorted indices of rightmost post of pair</span>
0287 vfgx=foutin(ix2+1)-foutin(jx2);                     <span class="comment">% length of left triangle to the right of the right post</span>
0288 yx=min(wright(ix2),vfgx);                           <span class="comment">% integration length</span>
0289 yx(foutin(jx2+1)&lt;foutin(ix2+1))=0;                  <span class="comment">% zap invalid triangles</span>
0290 wx2=ffact(ix2).*ffact(jx2).*yx.^2.*((0.5*(wright(jx2)-vfgx)+yx/3))./(wright(ix2).*wright(jx2)+(yx==0));
0291 
0292 <span class="comment">% integrate lower triangle and upper triangle that ends to its right</span>
0293 
0294 nxtu=max(nxtr-1,1);
0295 msk=msk0 &amp; (ffact(nxtu)&gt;0);
0296 ix3=infall(msk);                                    <span class="comment">% unsorted indices of leftmost post of pair</span>
0297 jx3=nxtu(msk);                                      <span class="comment">% unsorted indices of rightmost post of pair</span>
0298 vfgx=foutin(ix3)-foutin(jx3);                       <span class="comment">% length of upper triangle to the left of the lower post</span>
0299 yx=min(wleft(ix3),vfgx);                            <span class="comment">% integration length</span>
0300 yx(foutin(jx3+1)&lt;foutin(ix3))=0;                    <span class="comment">% zap invalid triangles</span>
0301 wx3=ffact(ix3).*ffact(jx3).*yx.*(wleft(ix3).*(wright(jx3)-vfgx)+yx.*(0.5*(wleft(ix3)-wright(jx3)+vfgx)-yx/3))./(wleft(ix3).*wright(jx3)+(yx==0));
0302 
0303 <span class="comment">% integrate upper triangle and lower triangle that starts to its right</span>
0304 
0305 nxtu=[nxtr(2:end) 1];
0306 msk=msk0 &amp; (ffact(nxtu)&gt;0);
0307 ix4=infall(msk);                                    <span class="comment">% unsorted indices of leftmost post of pair</span>
0308 jx4=nxtu(msk);                                      <span class="comment">% unsorted indices of rightmost post of pair</span>
0309 vfgx=foutin(ix4+1)-foutin(jx4-1);                   <span class="comment">% length of upper triangle to the left of the lower post</span>
0310 yx=min(wright(ix4),vfgx);                           <span class="comment">% integration length</span>
0311 wx4=ffact(ix4).*ffact(jx4).*yx.^2.*(0.5*vfgx-yx/3)./(wright(ix4).*wleft(jx4)+(yx==0));
0312 
0313 <span class="comment">% now create the matrix</span>
0314 
0315 iox=sort([ix1 ix2 ix3 ix4;jx1 jx2 jx3 jx4]);
0316 <span class="comment">% [iox;[wx1 wx2 wx3 wx4]&gt;0 ]</span>
0317 msk=iox(2,:)&lt;=(nfall+mfout)/2;
0318 iox(2,msk)=(nfall+mfout+1)-iox(2,msk);  <span class="comment">% convert negative frequencies to positive</span>
0319 <span class="keyword">if</span> highex
0320     iox(1,iox(1,:)==mfout-1)=mfout-2; <span class="comment">% merge highest two output nodes</span>
0321 <span class="keyword">end</span>
0322 <span class="keyword">if</span> lowex
0323     iox(1,iox(1,:)==2)=3; <span class="comment">% merge lowest two output nodes</span>
0324 <span class="keyword">end</span>
0325 
0326 x=sparse(iox(1,:)-1-lowex,max(iox(2,:)-nfall+nf+1,1),[wx1 wx2 wx3 wx4],p,nf);
0327 <span class="comment">%</span>
0328 <span class="comment">% sort out the output argument options</span>
0329 <span class="comment">%</span>
0330 <span class="keyword">if</span> ~any(w==<span class="string">'H'</span>)
0331     cf=mb;         <span class="comment">% output Hz instead of mel/erb/...</span>
0332 <span class="keyword">end</span>
0333 cf=cf(2:p+1);  <span class="comment">% remove dummy end frequencies</span>
0334 il=1;
0335 ih=nf;
0336 <span class="keyword">if</span> any(w==<span class="string">'n'</span>) <span class="comment">% round outputs to the centre of gravity bin</span>
0337     sx2=sum(x,2);
0338     msk=full(sx2~=0);
0339     vxc=zeros(p,1);
0340     vxc(msk)=round((x(msk,:)*(1:nf)')./sx2(msk));
0341     x=sparse(1:p,vxc,sx2,p,nf);
0342 <span class="keyword">end</span>
0343 <span class="keyword">if</span> nargout &gt; 2
0344     msk=full(any(x&gt;0,1));
0345     il=find(msk,1);
0346     <span class="keyword">if</span> ~numel(il)
0347         ih=1;
0348     <span class="keyword">elseif</span> nargout &gt;3
0349         ih=find(msk,1,<span class="string">'last'</span>);
0350     <span class="keyword">end</span>
0351     x=x(:,il:ih);
0352 <span class="keyword">end</span>
0353 <span class="keyword">if</span> any(w==<span class="string">'u'</span>)
0354     sx=sum(x,2);
0355     x=x./repmat(sx+(sx==0),1,size(x,2));
0356 <span class="keyword">end</span>
0357 <span class="comment">%</span>
0358 <span class="comment">% plot results if no output arguments or g option given</span>
0359 <span class="comment">%</span>
0360 <span class="keyword">if</span> ~nargout || any(w==<span class="string">'g'</span>) || any(w==<span class="string">'G'</span>) <span class="comment">% plot idealized filters</span>
0361     <span class="keyword">if</span> ~any(w==<span class="string">'g'</span>) &amp;&amp; ~any(w==<span class="string">'G'</span>)
0362         w=[w <span class="string">'G'</span>];
0363     <span class="keyword">end</span>
0364     newfig=0;
0365     <span class="keyword">if</span>  any(w==<span class="string">'g'</span>)
0366         plot(fa-df+(il:ih)*df,x');
0367         title([<span class="string">'filtbankm: mode = '</span> w]);
0368         xlabel([<span class="string">'Frequency ('</span> <a href="v_xticksi.html" class="code" title="function s=v_xticksi(ah)">v_xticksi</a> <span class="string">'Hz)'</span>]);
0369         ylabel(<span class="string">'Weight'</span>);
0370         newfig=1;
0371     <span class="keyword">end</span>
0372 
0373     <span class="keyword">if</span>  any(w==<span class="string">'G'</span>)
0374         <span class="keyword">if</span> newfig
0375             figure;
0376         <span class="keyword">end</span>
0377         imagesc(fa-df+(il:ih)*df,1:p,x);
0378         axis <span class="string">'xy'</span>
0379         colorbar;
0380         <a href="v_cblabel.html" class="code" title="function c=v_cblabel(l,h)">v_cblabel</a>(<span class="string">'Weight'</span>);
0381         <span class="keyword">switch</span> wr
0382             <span class="keyword">case</span> 1
0383                 type=<span class="string">'Log-spaced'</span>;
0384             <span class="keyword">case</span> 2
0385                 type=<span class="string">'Erb-spaced'</span>;
0386             <span class="keyword">case</span> 3
0387                 type=<span class="string">'Bark-spaced'</span>;
0388             <span class="keyword">case</span> 4
0389                 type=<span class="string">'Mel-spaced'</span>;
0390             <span class="keyword">otherwise</span>
0391                 type=<span class="string">'Linear-spaced'</span>;
0392         <span class="keyword">end</span>
0393         ylabel([type <span class="string">' Filter'</span>]);
0394         xlabel([<span class="string">'Frequency ('</span> <a href="v_xticksi.html" class="code" title="function s=v_xticksi(ah)">v_xticksi</a> <span class="string">'Hz)'</span>]);
0395         title([<span class="string">'filtbankm: mode = '</span> w]);
0396     <span class="keyword">end</span>
0397 
0398 <span class="keyword">end</span></pre></div>

<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>