<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Index for Directory v_mfiles</title>
  <meta name="keywords" content="v_mfiles">
  <meta name="description" content="Index for Directory v_mfiles">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for v_mfiles&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>

<h1>Index for v_mfiles</h1>

<h2>Matlab files in this directory:</h2>
<table>
<tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="Contents.html">Contents</a></td><td>Voicebox: Speech Processing Toolbox for MATLAB </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_activlev.html">v_activlev</a></td><td>V_ACTIVLEV Measure active speech level as in ITU-T P.56 [LEV,AF,FSO]=(sp,FS,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_activlevg.html">v_activlevg</a></td><td>V_ACTIVLEVG Measure active speech level robustly [LEV,AF,FSO]=(sp,FS,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_addnoise.html">v_addnoise</a></td><td>V_ADDNOISE Add noise at a chosen SNR [z,p,fso]=(s,fsx,snr,m,nb,fsa) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_atan2sc.html">v_atan2sc</a></td><td>V_ATAN2SC    sin and cosine of atan(y/x) [S,C,R,T]=(Y,X) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_axisenlarge.html">v_axisenlarge</a></td><td>V_AXISENLARGE - enlarge the axes of a figure (f,h) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_bark2frq.html">v_bark2frq</a></td><td>V_BARK2FRQ  Convert the BARK frequency scale to Hertz FRQ=(BARK) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_berk2prob.html">v_berk2prob</a></td><td>V_BERK2PROB convert Berksons to probability </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_besselratio.html">v_besselratio</a></td><td>V_BESSELRATIO calculate the Bessel function ratio besseli(v+1,x)./besseli(v,x) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_besselratioi.html">v_besselratioi</a></td><td>V_BESSELRATIOI calculate the inverse Bessel function ratio </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_bitsprec.html">v_bitsprec</a></td><td>V_BITSPREC round values to a specified fixed or floating precision (X,N,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_cblabel.html">v_cblabel</a></td><td>V_CBLABEL add a label to a colorbar c=(l,h) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ccwarpf.html">v_ccwarpf</a></td><td>V_CCWARPF  Warp cepstral coefficients M=(F,N,S) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_cent2frq.html">v_cent2frq</a></td><td>V_FRQ2ERB  Convert Hertz to Cents frequency scale [C,CR]=(FRQ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_cep2pow.html">v_cep2pow</a></td><td>V_CEP2POW convert cepstral means and variances to the power domain </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_chimv.html">v_chimv</a></td><td>V_CHIMV approximate mean and variance of non-central chi distribution [m,v]=(n,l,s) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_choosenk.html">v_choosenk</a></td><td>V_CHOOSENK All choices of K elements taken from 1:N [X]=(N,K) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_choosrnk.html">v_choosrnk</a></td><td>V_CHOOSRNK All choices of K elements taken from 1:N with replacement. [X]=(N,K) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_colormap.html">v_colormap</a></td><td>V_COLORMAP set and plot color map </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_convfft.html">v_convfft</a></td><td>V_CONFFT 1-D convolution or correlation using FFT </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_correlogram.html">v_correlogram</a></td><td>V_CORRELOGRAM calculate correlogram [y,ty]=(x,inc,nw,nlag,m,fs) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_distchar.html">v_distchar</a></td><td>V_DISTCHAR calculates the cosh spectral distance between AR coefficients D=(AR1,AR2,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_distchpf.html">v_distchpf</a></td><td>V_DISTCHPF calculates the cosh spectral distance between power spectra D=(PF1,PF2,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_disteusq.html">v_disteusq</a></td><td>V_DISTEUSQ calculate euclidean, squared euclidean or mahanalobis distance D=(X,Y,MODE,W) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_distisar.html">v_distisar</a></td><td>V_DISTISAR calculates the Itakura-Saito distance between AR coefficients D=(AR1,AR2,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_distispf.html">v_distispf</a></td><td>V_DISTISPF calculates the Itakura-Saito spectral distance between power spectra D=(PF1,PF2,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_distitar.html">v_distitar</a></td><td>V_DISTITAR calculates the Itakura distance between AR coefficients D=(AR1,AR2,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_distitpf.html">v_distitpf</a></td><td>V_DISTITPF calculates the Itakura spectral distance between power spectra D=(PF1,PF2,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ditherq.html">v_ditherq</a></td><td>V_DITHERQ  add dither and quantize [Y,ZF]=(X,M,ZI) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_dlyapsq.html">v_dlyapsq</a></td><td>V_DLYAPSQ Solves the discrete Lyapunov equation AV'VA' - V'V + BB' = 0 </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_dualdiag.html">v_dualdiag</a></td><td>V_DUALDIAG Simultaneous diagonalisation of two hermitian matrices [A,D,E]=(W,B) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_dypsa.html">v_dypsa</a></td><td>V_DYPSA   Derive glottal closure instances from speech [gci,goi] = (s,fs) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_enframe.html">v_enframe</a></td><td>V_ENFRAME split signal up into (overlapping) frames: one per row. [F,T]=(X,WIN,HOP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_entropy.html">v_entropy</a></td><td>V_ENTROPY calculates the v_entropy of discrete and sampled continuous distributions H=(P,DIM,COND,ARG,STEP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_erb2frq.html">v_erb2frq</a></td><td>V_ERB2FRQ  Convert ERB frequency scale to Hertz FRQ=(ERB) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_estnoiseg.html">v_estnoiseg</a></td><td>V_ESTNOISEG - estimate MMSE noise spectrum [x,zo]=(yf,tz,pp) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_estnoisem.html">v_estnoisem</a></td><td>V_ESTNOISEM - estimate noise spectrum using minimum statistics </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ewgrpdel.html">v_ewgrpdel</a></td><td>V_EWGRPDEL calculates the energy weighted group delay waveform Y=(X,W,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_fig2emf.html">v_fig2emf</a></td><td>V_FIG2EMF save a figure in windows metafile format (H,S,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_fig2pdf.html">v_fig2pdf</a></td><td>V_FIG2EMF save a figure in pdf/eps/ps formats (H,S,P,F) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_figbolden.html">v_figbolden</a></td><td>V_FIGBOLDEN embolden, resize and recolour the current figure =(POS,PV,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_filtbankm.html">v_filtbankm</a></td><td>V_FILTBANKM determine matrix for a linear/mel/erb/bark-spaced v_filterbank [X,IL,IH]=(P,N,FS,FL,FH,W) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_filterbank.html">v_filterbank</a></td><td>V_FILTERBANK appply v_filterbank to a signal: [y,zo]=(b,a,x,gd) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_findpeaks.html">v_findpeaks</a></td><td>V_FINDPEAKS finds peaks with optional quadratic interpolation [K,V]=(Y,M,W,X) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_finishat.html">v_finishat</a></td><td>V_FINISHAT print estimated finish time of a long computation (FRAC,TOL,FMT) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_fopenmkd.html">v_fopenmkd</a></td><td>V_FOPENMKD is the same as FOPEN but creates any missing directories [fid,mes]=(fn,pe,mf,en) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_frac2bin.html">v_frac2bin</a></td><td>V_FRAC2BIN Convert an column vector to binary S=(D,N,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_fram2wav.html">v_fram2wav</a></td><td>V_FRAM2WAV  converts frame values to a continuous waveform [W]=(X,TT,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_frq2bark.html">v_frq2bark</a></td><td>V_FRQ2BARK  Convert Hertz to BARK frequency scale BARK=(FRQ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_frq2cent.html">v_frq2cent</a></td><td>V_FRQ2ERB  Convert Hertz to Cents frequency scale [C,CR]=(FRQ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_frq2erb.html">v_frq2erb</a></td><td>V_FRQ2ERB  Convert Hertz to ERB frequency scale ERB=(FRQ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_frq2mel.html">v_frq2mel</a></td><td>V_FRQ2ERB  Convert Hertz to Mel frequency scale MEL=(FRQ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_frq2midi.html">v_frq2midi</a></td><td>V_FRQ2MIDI Convert frequencies to musical note numbers [N,T]=(F) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_fxpefac.html">v_fxpefac</a></td><td>V_FXPEFAC PEFAC pitch tracker [FX,TT,PV,FV]=(S,FS,TINC,M,PP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_fxrapt.html">v_fxrapt</a></td><td>V_FXRAPT RAPT pitch tracker [FX,VUV]=(S,FS,M,Q) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gammabank.html">v_gammabank</a></td><td>V_GAMMABANK gammatone filter bank [b,a,fx,bx,gd]=(n,fs,w,fc,bw,ph,k) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gammalns.html">v_gammalns</a></td><td>V_GAMMALNS Log of Gamma(x) for positive or negative real x [y,s]=(x) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gausprod.html">v_gausprod</a></td><td>V_GAUSPROD calculates a product of gaussians [G,U,K]=(M,C) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmix.html">v_gaussmix</a></td><td>V_GAUSSMIX fits a gaussian mixture pdf to a set of data observations [m,v,w,g,f]=(x,c,l,m0,v0,w0,wx) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmixd.html">v_gaussmixd</a></td><td>V_GAUSSMIXD marginal and conditional Gaussian mixture densities </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmixg.html">v_gaussmixg</a></td><td>V_GAUSSMIXG global mean, variance and mode of a GMM </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmixk.html">v_gaussmixk</a></td><td>V_GAUSSMIXK approximate Kullback-Leibler divergence between two GMMs + derivatives </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmixm.html">v_gaussmixm</a></td><td>V_GAUSSMIXM estimate mean and variance of the magnitude of a GMM </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmixp.html">v_gaussmixp</a></td><td>V_GAUSSMIXP calculate probability densities from or plot a Gaussian mixture model </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gaussmixt.html">v_gaussmixt</a></td><td>V_GAUSSMIXT Multiply two GMM pdfs </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_glotlf.html">v_glotlf</a></td><td>V_GLOTLF   Liljencrants-Fant glottal model U=(D,T,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_glotros.html">v_glotros</a></td><td>V_GLOTROS  Rosenberg glottal model U=(D,T,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_gmmlpdf.html">v_gmmlpdf</a></td><td>V_GMMLPDF obsolete function - please use GAUSSMIXP instead </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_histndim.html">v_histndim</a></td><td>V_HISTNDIM - generates and/or plots an n-dimensional histogram </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_horizdiff.html">v_horizdiff</a></td><td>V_HORIZDIFF - Estimates the horizontal difference between two functions of x </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_hostipinfo.html">v_hostipinfo</a></td><td>V_HOSTIPINFO get host name and internet connection information </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_huffman.html">v_huffman</a></td><td>V_HUFFMAN calculates a D-ary v_huffman code [CC,LL]=(P,A) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_hypergeom1f1.html">v_hypergeom1f1</a></td><td>V_HYPERGEOM1F1 Confluent hypergeometric function, 1F1 a.k.a Kummer's M function [h,l]=(a,b,z,tol,maxj) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_imagehomog.html">v_imagehomog</a></td><td>V_IMAGEHOMOG Apply a homography transformation to an image with bilinear interpolation </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_importsii.html">v_importsii</a></td><td>V_IMPORTSII calculates the SII importance function per Hz or per Bark Q=(F,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_irdct.html">v_irdct</a></td><td>V_IRDCT    Inverse discrete cosine transform of real data X=(Y,N) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_irfft.html">v_irfft</a></td><td>V_IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_kmeanhar.html">v_kmeanhar</a></td><td>V_KMEANHAR Vector quantisation using K-harmonic means algorithm [X,G,XN,GG]=(D,K,L,E,X0) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_kmeanlbg.html">v_kmeanlbg</a></td><td>V_KMEANLBG Vector quantisation using the Linde-Buzo-Gray algorithm [X,ESQ,J]=(D,K) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_kmeans.html">v_kmeans</a></td><td>V_KMEANS Vector quantisation using K-means algorithm [X,ESQ,J]=(D,K,X0,L) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lambda2rgb.html">v_lambda2rgb</a></td><td>V_LAMBDA2XYZ Convert wavelength to XYZ or RGB colour space X=(L,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ldatrace.html">v_ldatrace</a></td><td>V_LDATRACE Calculates an LDA transform to maximize trace discriminant [a,f,B,W]=(b,w,n,c) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lin2pcma.html">v_lin2pcma</a></td><td>V_LIN2PCMA Convert linear PCM to A-law P=(X,M,S) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lin2pcmu.html">v_lin2pcmu</a></td><td>V_LIN2PCMU Convert linear to Mu-law PCM P=(X,S) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lognmpdf.html">v_lognmpdf</a></td><td>V_LOGNMPDF calculate pdf of a multivariate lognormal distribution P=(X,M,V) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_logsum.html">v_logsum</a></td><td>V_LOGSUM v_logsum(x,d,k)=log(sum(k.*exp(x),d)) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcaa2ao.html">v_lpcaa2ao</a></td><td>V_LPCAA2AO LPC: Convert area function to area ratios AO=(AA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcaa2dl.html">v_lpcaa2dl</a></td><td>V_LPCAA2DL LPC: Convert area coefficients to dct of log area DL=(AA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcaa2rf.html">v_lpcaa2rf</a></td><td>V_LPCAA2RF LPC: Convert vocal tract areas to reflection coefficients RF=(AA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcao2rf.html">v_lpcao2rf</a></td><td>V_LPCAO2RF LPC: Convert area ratios to reflection coefficients RF=(AO) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2am.html">v_lpcar2am</a></td><td>V_LPCAR2AM Convert ar coefs to ar coef matrix [AM,EM]=(AR,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2cc.html">v_lpcar2cc</a></td><td>V_LPCAR2CC LPC: Convert AR filter to complex cepstrum [CC,C0]=(AR,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2db.html">v_lpcar2db</a></td><td>V_LPCAR2DB LPC: Convert AR coefs to power spectrum in dB DB=(AR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2ff.html">v_lpcar2ff</a></td><td>V_LPCAR2FF LPC: Convert AR coefs to complex spectrum FF=(AR,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2fm.html">v_lpcar2fm</a></td><td>V_LPCAR2RF Convert autoregressive coefficients to formant freq+amp+bw [N,F,A,B]=(AR,T) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2im.html">v_lpcar2im</a></td><td>V_LPCAR2IM Convert AR coefs to impulse response IM=(AR,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2ls.html">v_lpcar2ls</a></td><td>V_LPCAR2LS convert ar polynomial to line spectrum pair frequencies LS=(AR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2pf.html">v_lpcar2pf</a></td><td>V_LPCAR2PF Convert AR coefs to power spectrum PF=(AR,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2pp.html">v_lpcar2pp</a></td><td>V_LPCAR2PP LPC: Convert ar filter to power spectrum polynomial in cos(w) PP=(AR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2ra.html">v_lpcar2ra</a></td><td>V_LPCAR2RA Convert ar filter to inverse filter autocorrelation coefs. RA=(AR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2rf.html">v_lpcar2rf</a></td><td>V_LPCAR2RF Convert autoregressive coefficients to reflection coefficients AR=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2rr.html">v_lpcar2rr</a></td><td>V_LPCAR2RR Convert autoregressive coefficients to autocorrelation coefficients RR=(AR,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcar2zz.html">v_lpcar2zz</a></td><td>V_LPCAR2ZZ Convert ar filter to z-plane poles ZZ=(AR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcauto.html">v_lpcauto</a></td><td>V_LPCAUTO  performs autocorrelation LPC analysis [AR,E,K]=(S,P,T) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcbwexp.html">v_lpcbwexp</a></td><td>V_LPCBWEXP expand formant bandwidths of LPC filter ARX=(AR,BW) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccc2ar.html">v_lpccc2ar</a></td><td>V_LPCCC2AR Convert complex cepstrum to ar coefficients AR=(CC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccc2cc.html">v_lpccc2cc</a></td><td>V_LPCCC2PF Extrapolate complex cepstrum C=(CC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccc2db.html">v_lpccc2db</a></td><td>V_LPCCC2DB Convert complex cepstrum to dB power spectrum DB=(CC,NP,NC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccc2ff.html">v_lpccc2ff</a></td><td>V_LPCCC2FF Convert complex cepstrum to complex spectrum FF=(CC,NP,NC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccc2pf.html">v_lpccc2pf</a></td><td>V_LPCCC2PF Convert complex cepstrum to power spectrum PF=(CC,NP,NC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcconv.html">v_lpcconv</a></td><td>V_LPCCONV(from,to,x,y)->s convert between LPC parameter sets </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccovar.html">v_lpccovar</a></td><td>V_LPCCOVAR performs covariance LPC analysis [AR,E,DC]=(S,P,T) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpccw2zz.html">v_lpccw2zz</a></td><td>V_LPCPZ2ZZ LPC: Power spectrum roots to LPC poles ZZ=(CW) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcdb2pf.html">v_lpcdb2pf</a></td><td>V_LPCDB2PF Convert decibel power spectrum to power spectrum PF=(DB) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcdl2aa.html">v_lpcdl2aa</a></td><td>V_LPCDL2AA dct of log area to area coefficients AA=(DL) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcff2pf.html">v_lpcff2pf</a></td><td>V_LPCFF2PF Convert complex spectrum to power spectrum PF=(FF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcfq2zz.html">v_lpcfq2zz</a></td><td>V_LPCFQ2ZZ Convert frequencies and q factors to z-plane poles ZZ=(F,Q) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcifilt.html">v_lpcifilt</a></td><td>V_LPCIFILT Apply inverse filter to speech signal U=(S,AR,T,DC,FADE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcim2ar.html">v_lpcim2ar</a></td><td>V_LPCIM2AR Convert impulse response to AR coefs AR=(IM) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcis2rf.html">v_lpcis2rf</a></td><td>V_LPCRF2IS Convert inverse sines to reflection coefficients RF=(IS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcla2rf.html">v_lpcla2rf</a></td><td>V_LPCLA2RF Convert log areas to reflection coefficients RF=(LA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpclo2rf.html">v_lpclo2rf</a></td><td>V_LPCLO2RF Convert log area ratios to reflection coefficients RF=(LO) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcls2ar.html">v_lpcls2ar</a></td><td>V_LPCLS2AR convert line spectrum pair frequencies to ar polynomial AR=(LS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcpf2cc.html">v_lpcpf2cc</a></td><td>V_LPCPF2CC Convert power spectrum to complex cepstrum CC=(PF,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcpf2ff.html">v_lpcpf2ff</a></td><td>V_LPCPF2FF Convert power spectrum to complex spectrum [FF,FO]=(PF,NP,FI) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcpf2rr.html">v_lpcpf2rr</a></td><td>V_LPCPF2RR convert power spectrum to autocorrelation coefs RR=(PF,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcpp2cw.html">v_lpcpp2cw</a></td><td>V_LPCPP2PZ LPC: Convert power spectrum polynomial in cos(w) to power spectrum zeros CW=(RP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcpp2pz.html">v_lpcpp2pz</a></td><td>V_LPCPP2PZ LPC: Convert power spectrum polynomial in cos(w) to power spectrum zeros PZ=(RP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcpz2zz.html">v_lpcpz2zz</a></td><td>V_LPCPZ2ZZ LPC: Power spectrum roots to LPC poles ZZ=(PZ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcra2ar.html">v_lpcra2ar</a></td><td>V_LPCRA2AR Convert inverse filter autocorrelation coefs to AR filter. AR=(RA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcra2pf.html">v_lpcra2pf</a></td><td>V_LPCAR2PF Convert AR coefs to power spectrum PF=(RA,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcra2pp.html">v_lpcra2pp</a></td><td>V_LPCAR2PP LPC: Convert ar filter autocorrelation to power spectrum polynomial in cos(w) PP=(RA) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrand.html">v_lpcrand</a></td><td>V_LPCRAND generate random stable polynomials AR=(P,N,BW) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2aa.html">v_lpcrf2aa</a></td><td>V_LPCRF2AA Convert reflection coefficients to area function AA=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2ao.html">v_lpcrf2ao</a></td><td>V_LPCRF2AO Convert reflection coefficients to area ratios AO=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2ar.html">v_lpcrf2ar</a></td><td>V_LPCRF2AR Convert reflection coefs to autoregressive coefs [AR,ARP,ARU,G]=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2is.html">v_lpcrf2is</a></td><td>V_LPCRF2IS Convert reflection coefficients to inverse sines IS=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2la.html">v_lpcrf2la</a></td><td>V_LPCRF2LA Convert reflection coefficients to log areas LA=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2lo.html">v_lpcrf2lo</a></td><td>V_LPCRF2LO Convert reflection coefficients to log area ratios LO=(RF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrf2rr.html">v_lpcrf2rr</a></td><td>V_LPCRR2AR convert reflection coefs to autocorrelation coefs [RR,AR]=(RF,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrr2am.html">v_lpcrr2am</a></td><td>V_LPCRR2AM Convert autocorrelation coefs to ar coef matrix [AM,EM]=(RR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcrr2ar.html">v_lpcrr2ar</a></td><td>V_LPCRR2AR convert autocorrelation coefs to ar coefs [AR,E]=(RR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcss2zz.html">v_lpcss2zz</a></td><td>V_LPCSS2ZZ Convert s-place poles to z-plane poles ZZ=(SS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpcstable.html">v_lpcstable</a></td><td>V_LPCSTABLE Test AR coefficients for stability and stabilize if necessary [MA,A]=(AR) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpczz2ar.html">v_lpczz2ar</a></td><td>V_LPCZZ2AR Convert z-place poles to ar coefficients AR=(ZZ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpczz2cc.html">v_lpczz2cc</a></td><td>V_LPCZZ2CC Convert poles to "complex" cepstrum CC=(ZZ,NP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_lpczz2ss.html">v_lpczz2ss</a></td><td>V_LPCZZ2SS Convert z-place poles to s-plane poles SS=(ZZ) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_m2htmlpwd.html">v_m2htmlpwd</a></td><td>V_M2HTMLPWD - create html documentation of files in current directory </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_maxfilt.html">v_maxfilt</a></td><td>V_MAXFILT find max of an exponentially weighted sliding window  [Y,K,Y0]=(X,F,nn,D,X0) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_maxgauss.html">v_maxgauss</a></td><td>V_MAXGAUSS determine gaussian approximation to max of a gaussian vector [p,u,v,r]=(m,c,d) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_meansqtf.html">v_meansqtf</a></td><td>V_AVEPSPEC calculates the mean square transfer function for a filter D=(B,A) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_mel2frq.html">v_mel2frq</a></td><td>V_MEL2FRQ  Convert Mel frequency scale to Hertz FRQ=(MEL) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_melbankm.html">v_melbankm</a></td><td>V_MELBANKM determine matrix for a mel/erb/bark-spaced v_filterbank [X,MN,MX]=(P,N,FS,FL,FH,W) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_melcepst.html">v_melcepst</a></td><td>V_MELCEPST Calculate the mel cepstrum of a signal C=(S,FS,W,NC,P,N,INC,FL,FH) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_midi2frq.html">v_midi2frq</a></td><td>V_MIDI2FRQ	Convert musical note numbers to frequencies F=(N,S) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_minspane.html">v_minspane</a></td><td>V_MINSPANE calculate minimum spanning tree using euclidean distance [p,s]=X </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_mintrace.html">v_mintrace</a></td><td>V_MINTRACE find row permutation to minimize the trace p=(x) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_modspect.html">v_modspect</a></td><td>V_MODSPECT Calculate the modulation spectrum of a signal C=(S,FS,W,NC,P,N,INC,FL,FH) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_momfilt.html">v_momfilt</a></td><td>V_MOMFILT calculates moments of a signal using a sliding window Y=(X,R,W,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_mos2pesq.html">v_mos2pesq</a></td><td>V_MOS2PESQ convert MOS speech quality scores to PESQ p=(m) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_nearnonz.html">v_nearnonz</a></td><td>V_NEARNONZ replace each zero element with the nearest non-zero element [V,Y,W]=v_nearnonz(X,D) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_normcdflog.html">v_normcdflog</a></td><td>V_NORMCDFLOG calculates log of Normal Cumulative Distribution function p=(x,m,s) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_overlapadd.html">v_overlapadd</a></td><td>V_OVERLAPADD join overlapping frames together X=(F,WIN,INC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_paramsetch.html">v_paramsetch</a></td><td>V_PARAMSETCH update and check parameter values p=(d,q,m,c,t) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_pcma2lin.html">v_pcma2lin</a></td><td>V_PCMU2LIN Convert A-law PCM to linear X=(P,M,S) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_pcmu2lin.html">v_pcmu2lin</a></td><td>V_PCMU2LIN Convert Mu-law PCM to linear X=(P,S) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_pdfmoments.html">v_pdfmoments</a></td><td>V_PDFMOMENTS convert between central moments, raw moments and cumulants [C,R,K]=(T,M,B,A) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_peak2dquad.html">v_peak2dquad</a></td><td>V_PEAK2DQUAD find quadratically-interpolated peak in a 2D array </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_permutes.html">v_permutes</a></td><td>V_PERMUTES All N! permutations of 1:N + signatures [P,S]=(N) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_pesq2mos.html">v_pesq2mos</a></td><td>V_PESQ2MOS convert PESQ speech quality scores to MOS m=(p) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_phon2sone.html">v_phon2sone</a></td><td>V_PHON2SONE convert PHON loudness values to SONEs s=(p) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_polygonarea.html">v_polygonarea</a></td><td>V_POLYGONAREA Calculate the area of a polygon </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_polygonwind.html">v_polygonwind</a></td><td>V_POLYGONWIND Test if points are inside a polygon </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_polygonxline.html">v_polygonxline</a></td><td>V_POLYGONXLINE Find where a line crosses a polygon [xc,ec,tc,xy0]=(p,l) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_potsband.html">v_potsband</a></td><td>V_POTSBAND Design filter for 300-3400 telephone bandwidth [B,A]=(FS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_pow2cep.html">v_pow2cep</a></td><td>V_CEP2POW convert cepstral means and variances to the power domain </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ppmvu.html">v_ppmvu</a></td><td>V_V_PPMVU calculate PPM, VU or EBU level of an audio signal [V,FX,FX1]=(X,FSX,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_prob2berk.html">v_prob2berk</a></td><td>V_PROB2BERK convert probability to Berksons </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_psycdigit.html">v_psycdigit</a></td><td>V_PSYCDIGIT measures psychometric function using TIDIGITS stimuli </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_psycest.html">v_psycest</a></td><td>V_PSYCEST estimate multiple psychometric functions </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_psycestu.html">v_psycestu</a></td><td>V_PSYCESTU estimate unimodal psychometric function </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_psychofunc.html">v_psychofunc</a></td><td>V_PSYCHOFUNC Calculate psychometric functions: trial success probability versus SNR </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_qrabs.html">v_qrabs</a></td><td>V_QRABS absolute value and normalization of a real quaternions [m,q]=[q1] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_qrdivide.html">v_qrdivide</a></td><td>V_QRDIVIDE divdes two real quaternions q=[q1,q2] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_qrdotdiv.html">v_qrdotdiv</a></td><td>V_QRDOTDIV divides two real quaternions arrays elementwise q=[x,y] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_qrdotmult.html">v_qrdotmult</a></td><td>V_QRDOTMULT multiplies together two real quaternions arrays q=[q1,q2] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_qrmult.html">v_qrmult</a></td><td>V_QRMULT multiplies together two real quaternions matrices q=[q1,q2] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_qrpermute.html">v_qrpermute</a></td><td>V_QRPERMUTE transpose or permute a quaternion array y=[x,p] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_quadpeak.html">v_quadpeak</a></td><td>V_PEAK2DQUAD find quadratically-interpolated peak in a N-D array </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_randfilt.html">v_randfilt</a></td><td>V_RANDFILT Generate filtered gaussian noise without initial transient </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_randiscr.html">v_randiscr</a></td><td>V_RANDISCR Generate discrete random numbers with specified probabiities [X]=(P,N,A) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_randvec.html">v_randvec</a></td><td>V_RANDVEC  Generate real or complex GMM/lognormal random vectors X=(N,M,C,W,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rdct.html">v_rdct</a></td><td>V_RDCT     Discrete cosine transform of real data Y=(X,N,A,B) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readaif.html">v_readaif</a></td><td>V_READAIF  Read a .AIF format sound file [Y,FS,WMODE,FIDX]=(FILENAME,MODE,NMAX,NSKIP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readau.html">v_readau</a></td><td>V_READAU  Read a SUN .AU format sound file [Y,FS,H]=(FILENAME) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readcnx.html">v_readcnx</a></td><td>V_READCNX  Read a .CNX format sound file [Y,FS,H]=(FILENAME) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readflac.html">v_readflac</a></td><td>V_READFLAC  Read a .FLAC format sound file [Y,FS]=(FILENAME,MODE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readhtk.html">v_readhtk</a></td><td>V_READHTK  read an HTK parameter file [D,FP,DT,TC,T]=(FILE) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readsfs.html">v_readsfs</a></td><td>V_READSFS  Read a .SFS format sound file [Y,FS,HD,FFX]=(FF,TY,SUB,MODE,NMAX,NSKIP,XPATH) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readsph.html">v_readsph</a></td><td>V_READSPH  Read a SPHERE/TIMIT format sound file [Y,FS,WRD,PHN,FFX]=(FILENAME,MODE,NMAX,NSKIP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_readwav.html">v_readwav</a></td><td>V_READWAV  Read a .WAV format sound file [Y,FS,WMODE,FIDX]=(FILENAME,MODE,NMAX,NSKIP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rectifyhomog.html">v_rectifyhomog</a></td><td>V_RECTIFYHOMOG Apply rectifying homographies to an image set </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_regexfiles.html">v_regexfiles</a></td><td>V_REGEXFILES recursively searches for files matching a pattern tok=(regex,root) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_resample.html">v_resample</a></td><td>V_V_RESAMPLE Resample and remove end transients [y,h]=(x,p,q,n,b) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rfft.html">v_rfft</a></td><td>V_RFFT     Calculate the DFT of real data Y=(X,N,D) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rhartley.html">v_rhartley</a></td><td>V_RHARTLEY Calculate the Hartley transform of real data Y=(X,N) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rnsubset.html">v_rnsubset</a></td><td>V_RNSUBSET choose k distinct random integers from 1:n M=(K,N) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotation.html">v_rotation</a></td><td>V_ROTATION Encode and decode rotation matrices </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotax2qr.html">v_rotax2qr</a></td><td>V_ROTQR2AX converts a rotation axis and angle to the corresponding real quaternion </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_roteu2qr.html">v_roteu2qr</a></td><td>ROTEU2QR converts a sequence of Euler angles to a real unit quaternion </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_roteu2ro.html">v_roteu2ro</a></td><td>V_ROTEU2QR converts a sequence of Euler angles to a rotation matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_roteucode.html">v_roteucode</a></td><td>V_ROTEUCODE decodes a string specifying a rotation axis sequence </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotmc2qc.html">v_rotmc2qc</a></td><td>V_ROTMC2QC converts a matrix of complex quaternion matrices to a matrix of complex quaternion vectors </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotmr2qr.html">v_rotmr2qr</a></td><td>V_ROTMR2QR converts a matrix of real quaternion matrices to quaternion vectors </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotpl2ro.html">v_rotpl2ro</a></td><td>V_ROTPL2RO find matrix to rotate in the plane containing u and v r=[u,v,t] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqc2mc.html">v_rotqc2mc</a></td><td>V_ROTQC2MC converts a matrix of complex quaternion vectors to quaternion matrices </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqc2qr.html">v_rotqc2qr</a></td><td>V_ROTQC2QR converts a matrix of complex quaternion row vectors into real form </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqr2ax.html">v_rotqr2ax</a></td><td>V_ROTQR2AX converts a real quaternion to the corresponding rotation axis and angle </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqr2eu.html">v_rotqr2eu</a></td><td>V_ROTQR2EQ converts a real unit quaternion into the corresponding euler angles </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqr2mr.html">v_rotqr2mr</a></td><td>V_ROTQR2MR converts a matrix of real quaternion vectors to quaternion matrices </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqr2qc.html">v_rotqr2qc</a></td><td>V_ROTQR2QC converts a matrix of real quaternion vectors into complex form </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqr2ro.html">v_rotqr2ro</a></td><td>ROTQR2RO converts a real quaternion to a 3x3 rotation matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqrmean.html">v_rotqrmean</a></td><td>V_ROTQRMEAN calculates the mean rotation of a quaternion array [y,s]=[q] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotqrvec.html">v_rotqrvec</a></td><td>V_ROTQRVEC applies a quaternion rotation ot a vector array y=[q,x] </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotro2eu.html">v_rotro2eu</a></td><td>V_ROTRO2EU converts a 3x3 rotation matrix into the corresponding euler angles </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotro2pl.html">v_rotro2pl</a></td><td>V_ROTRO2PL find the plane and rotation angle of a rotation matrix [u,v,t]=r </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rotro2qr.html">v_rotro2qr</a></td><td>V_ROTRO2QR converts a 3x3 rotation matrix to a real quaternion </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_rsfft.html">v_rsfft</a></td><td>V_RSFFT    fft of a real symmetric spectrum X=(Y,N) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sapisynth.html">v_sapisynth</a></td><td>V_SAPISYNTH  text-to-speech synthesize of text string or matrix [X,FS,TXT]=(T,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_schmitt.html">v_schmitt</a></td><td>V_SCHMITT Pass input signal X through a v_schmitt trigger </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sigalign.html">v_sigalign</a></td><td>V_SIGALIGN align a clean reference with a noisy signal [d,g,rr,ss]=(s,r,maxd,m,fs) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sigma.html">v_sigma</a></td><td>V_SIGMA Estimate glottal opening an closing instants </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_skew3d.html">v_skew3d</a></td><td>V_SKEW3D Convert between a vector and the corresponding skew-symmetric matrix </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_snrseg.html">v_snrseg</a></td><td>V_SNRSEG Measure segmental and global SNR [SEG,GLO]=(S,R,FS,M,TF) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sone2phon.html">v_sone2phon</a></td><td>V_PHON2SONE convert SONE loudness values to PHONs p=(s) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_soundspeed.html">v_soundspeed</a></td><td>V_SOUNDSPEED gives the speed of sound, density of air and acoustic impedance as a function of temp & pressure [V,D,Z]=(T,P,M,G) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_specsub.html">v_specsub</a></td><td>V_SPECSUB performs speech enhancement using spectral subtraction [SS,ZO]=(S,FSZ,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_specsubm.html">v_specsubm</a></td><td>V_SPECSUBM obsolete speech enhancement algorithm - use v_specsub instead </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_spendred.html">v_spendred</a></td><td>V_SPENDRED Speech Enhancement and Dereverberation by Doire </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_spgrambw.html">v_spgrambw</a></td><td>V_SPGRAMBW Draw spectrogram [T,F,B]=(s,fs,mode,bw,fmax,db,tinc,ann) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sphrharm.html">v_sphrharm</a></td><td>V_SPHRHARM  forward and inverse spherical harmonic transform </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sprintcpx.html">v_sprintcpx</a></td><td>V_SPRINTCPX  format a complex number for printing S=(Z,F) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_sprintsi.html">v_sprintsi</a></td><td>V_SPRINTSI Print X with SI multiplier S=(X,D,W,U) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ssubmmse.html">v_ssubmmse</a></td><td>V_SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or log amplitude [SS,ZO]=(S,FSZ,PP) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_ssubmmsev.html">v_ssubmmsev</a></td><td>V_SSUBMMSE performs speech enhancement using mmse estimate of spectral amplitude or log amplitude [SS,ZO]=(S,FSZ,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_stdspectrum.html">v_stdspectrum</a></td><td>V_STDSPECTRUM Generate standard acoustic/speech spectra in s- or z-domain [B,A,SI,SN]=(S,M,F,N,ZI,BS,AS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_stoi2prob.html">v_stoi2prob</a></td><td>V_STOI2PROB convert STOI to probability </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_teager.html">v_teager</a></td><td>V_TEAGER calculate v_teager energy waveform Y=(X,D,M) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_texthvc.html">v_texthvc</a></td><td>V_TEXTHVC - write text on graph with specified alignment and colour </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_tilefigs.html">v_tilefigs</a></td><td>V_TILEFIGS tile current figures </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_txalign.html">v_txalign</a></td><td>V_TXALIGN Find the best alignment of two sets of time markers [KX,KY,N,M,S]=(X,Y,MAXT) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_unixwhich.html">v_unixwhich</a></td><td>V_UNIXWHICH Search system path for an executable program [F]=(C,E) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_upolyhedron.html">v_upolyhedron</a></td><td>V_UPOLYHEDRON calculate uniform polyhedron characteristics </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_usasi.html">v_usasi</a></td><td>V_USASI generates N samples of USASI noise at sample frequency FS X=(N,FS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_vadsohn.html">v_vadsohn</a></td><td>V_VADSOHN implements a voice activity detector [VS,ZO]=(S,FSZ,M,P) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_voicebox.html">v_voicebox</a></td><td>V_VOICEBOX  set global parameters for Voicebox functions Y=(FIELD,VAL) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_voicebox_update.html">v_voicebox_update</a></td><td>V_VOICEBOX_UPDATE update v_voicebox calls by prefixing with 'v_' </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_vonmisespdf.html">v_vonmisespdf</a></td><td>V_VONMISESPDF Von Mises probability distribution P=(x,m,k) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_windinfo.html">v_windinfo</a></td><td>V_WINDINFO window information and figures of merit X=(W,FS) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_windows.html">v_windows</a></td><td>V_WINDOWS Generate a standard windowing function (TYPE,N,MODE,P,H) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_winenvar.html">v_winenvar</a></td><td>V_WINENVAR get windows environment variable [D]=(N) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_writehtk.html">v_writehtk</a></td><td>V_WRITEHTK write data in HTK format []=(FILE,D,FP,TC) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_writewav.html">v_writewav</a></td><td>V_WRITEWAV Creates .WAV format sound files FIDX=(D,FS,FILENAME,MODE,NSKIP,MASK,MAD) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_xticksi.html">v_xticksi</a></td><td>V_XTIXKSI labels the x-axis of a plot using SI multipliers S=(AH) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_xyzticksi.html">v_xyzticksi</a></td><td>V_XYZTIXKSI labels an axis of a plot using SI multipliers S=(AX,AH) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_yticksi.html">v_yticksi</a></td><td>V_YTIXKSI labels the y-axis of a plot using SI multipliers S=(AH) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_zerocros.html">v_zerocros</a></td><td>V_ZEROCROS finds the zeros crossings in a signal [T,S]=(Y,M,X) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_zerotrim.html">v_zerotrim</a></td><td>V_ZEROTRIM Remove zero trailing rows and columns Z=(X) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="v_zoomfft.html">v_zoomfft</a></td><td>V_ZOOMFFT    DTFT evaluated over a linear frequency range Y=(X,N,M,S,D) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="wavread.html">wavread</a></td><td>WAVREAD  Legacy MATLAB function to read .WAV file [Y,FS,BITS]=(FILENAME,NMAX) </td></tr><tr><td><img src="../matlabicon.gif" alt="" border="">&nbsp;<a href="wavwrite.html">wavwrite</a></td><td>WAVREAD  Legacy MATLAB function to write .WAV file (Y,Fs,N,FILENAME) </td></tr></table>


<h2>Subsequent directories:</h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li>doc</li></ul>

<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>